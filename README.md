# SalvaJSON

[`salvajson`](https://github.com/twardoch/salvajson) is a Python package for fixing corrupted JSON files. It uses the lenient [`jsonic`](https://github.com/rjrodger/jsonic) parser (via the [`pythonmonkey`](https://github.com/Distributive-Network/PythonMonkey) Python-JS bridge) and [`orjson`](https://github.com/ijl/orjson) for high-performance operations.

- Seamlessly corrects invalid JSON from LLMs, APIs, and other sources.
- Handles missing/single quotes, trailing commas, missing commas, unquoted strings, JSON comments, and more.
- Simple Python API and command-line interface.
- Uses `hatch-vcs` for versioning from Git tags and `python-semantic-release` for automated changelog generation and release management.
- Code quality is maintained with `pre-commit` hooks including `ruff`, `mypy`, `prettier`, `bandit`, and `commitlint`.

## Installation

```bash
pip install salvajson
# Or using uv:
# uv pip install salvajson
```

### Requirements

- Python 3.10 or higher
- PythonMonkey 1.1.0 or higher (automatically installed)

## Usage

### Python API

```python
from salvajson import salvaj, dumps, loads

# Fix a corrupted JSON string
corrupted_json = """{
    name: "John",
    age: 30,
    'hobbies': ['reading' 'coding'], // Missing comma, single quotes for key
}"""

fixed_json_string = salvaj(corrupted_json)
print(f"Fixed JSON string: {fixed_json_string}")
# Output: Fixed JSON string: {"name":"John","age":30,"hobbies":["reading","coding"]}

# Parse the fixed string (or any valid/corrupted JSON)
data = loads(fixed_json_string)
print(f"Parsed data: {data}")
# Output: Parsed data: {'name': 'John', 'age': 30, 'hobbies': ['reading', 'coding']}

# Serialize Python objects to JSON
pretty_json = dumps(data, indent=2, sort_keys=True)
print(f"Serialized, pretty JSON:\n{pretty_json}")
# Output:
# Serialized, pretty JSON:
# {
#   "age": 30,
#   "hobbies": [
#     "reading",
#     "coding"
#   ],
#   "name": "John"
# }
```

The package provides three main functions:

#### `salvaj(json_str: str) -> str`

Fixes corrupted JSON strings using the lenient `jsonic` parser. This is the core function that handles many common JSON syntax issues.

#### `dumps(obj, *, indent=None, sort_keys=False, **kw) -> str`

High-performance JSON serialization using `orjson`. It's faster than the standard `json.dumps()` and supports common parameters like `indent` and `sort_keys`.

#### `loads(s: bytes | str, **kw) -> Any`

High-performance JSON parsing using `orjson`, with an automatic fallback to `salvaj` (and thus `jsonic`) if standard parsing fails due to malformed JSON.

### Command Line Interface

Salvajson comes with a CLI for processing JSON files directly:

```bash
# Process a single file and print to stdout
python -m salvajson path/to/corrupted.json

# Process and save to a new file
python -m salvajson input.json > output.json
```

## Development

### Setup Development Environment

1.  Clone the repository:
    ```bash
    git clone https://github.com/twardoch/salvajson.git
    cd salvajson
    ```

2.  Create and activate a virtual environment (recommended):
    ```bash
    python -m venv .venv
    source .venv/bin/activate  # On Windows: .venv\Scripts\activate
    ```

3.  Install the package in editable mode with development and test dependencies:
    ```bash
    pip install -e ".[dev,test]"
    ```

4.  Install JavaScript dependencies (for the `js_src` part):
    ```bash
    cd js_src
    npm ci # Recommended for CI/reproducible builds, or npm install
    cd ..
    ```

5.  Install pre-commit hooks:
    ```bash
    # Ensures code quality and consistent commit messages
    pre-commit install
    pre-commit install --hook-type commit-msg # For commit message linting (commitlint)
    ```

### Project Structure

```text
salvajson/
├── .github/workflows/    # GitHub Actions CI/CD workflows
├── src/
│   └── salvajson/
│       ├── __init__.py       # Main package interface
│       ├── _version.py       # Version information (uses importlib.metadata, populated by Hatch)
│       ├── salvajson.py      # Core Python logic
│       └── salvajson.js      # Bundled JavaScript code (generated by esbuild)
├── js_src/                 # JavaScript source code
│   ├── package.json          # JavaScript dependencies (npm)
│   ├── salvajson.src.js      # Main JavaScript source for jsonic wrapper
│   └── build.esbuild.js      # esbuild configuration for bundling JS
├── tests/                  # Pytest tests
│   └── test_salvajson.py
├── .pre-commit-config.yaml # Pre-commit hook configurations (ruff, mypy, prettier, bandit, commitlint)
├── build.py                # Hatchling build hook (handles JS bundling during Python package build)
├── commitlint.config.js    # Configuration for commitlint (Conventional Commits)
├── pyproject.toml          # Python package configuration (PEP 621, Hatch, Ruff, Mypy, Bandit, python-semantic-release)
├── README.md               # This file
├── CHANGELOG.md            # Changelog (managed by python-semantic-release)
└── LICENSE                 # Apache 2.0 License
```

### Building

The project uses [`hatchling`](https://hatch.pypa.io/latest/) as its build backend, configured in `pyproject.toml`. The `build.py` script defines a Hatchling build hook that automatically bundles the JavaScript code from `js_src/` into `src/salvajson/salvajson.js` before building the Python package.

To build the package (e.g., for distribution or local testing):
```bash
hatch build
```
This command will produce a wheel (`.whl`) and a source distribution (`.tar.gz`) in the `dist/` directory.

For development, installing in editable mode (as shown in the setup instructions) is usually sufficient. The build hook ensures the JavaScript bundle (`salvajson.js`) is generated during the editable install. If you modify JavaScript files in `js_src/` after the initial editable install, you may need to manually trigger the JS bundling:
```bash
python build.py
```
Then, the changes to `salvajson.js` should be picked up by your editable install. Alternatively, reinstalling (`pip install -e .[dev,test]`) will also rebuild the JS bundle.

## How It Works

Salvajson uses PythonMonkey to create a bridge between Python and JavaScript, allowing it to leverage the powerful `jsonic` parser. When you pass a JSON string to `salvaj()`:

1.  The string is passed to the JavaScript runtime.
2.  `jsonic` attempts to parse and fix the JSON.
3.  If successful, the fixed JSON is returned to Python as a string.
4.  If `jsonic` encounters an error it cannot recover from, this error is propagated to Python as a `pythonmonkey.SpiderMonkeyError`.

## License

Apache License 2.0 - see LICENSE file for details.

## Contributing

Contributions are welcome! Please make sure to:
- Follow the [Conventional Commits](https://www.conventionalcommits.org/) specification for your commit messages.
- Ensure `pre-commit` checks pass before submitting a Pull Request.

## Credits

- **Adam Twardoch** [@twardoch](https://github.com/twardoch)
- **Anthropic Claude**
- [jsonic](https://github.com/rjrodger/jsonic) - The lenient JSON parser in JavaScript
- [PythonMonkey](https://github.com/Distributive-Network/PythonMonkey) - Python-JavaScript bridge
- [orjson](https://github.com/ijl/orjson) - Fast JSON library for Python

## Rationale

This project serves as an exercise demonstrating how to effectively bridge Python and JavaScript ecosystems. It showcases:

- Integration of mature JavaScript libraries into Python applications using PythonMonkey.
- Clean architecture for JavaScript-Python interoperability.
- Proper packaging of JavaScript dependencies within a Python package.
- Modern build system configuration using `hatchling` and `esbuild`.
- Automated workflows for dependency management, CI (including `npm audit` and `pre-commit` checks), and publishing.
- Automated code quality checks and consistent commit messages using pre-commit hooks (Ruff, Mypy, Prettier, Bandit, Commitlint).
- Automated versioning and changelog generation using `hatch-vcs` and `python-semantic-release`.

While the project solves a specific problem (fixing malformed JSON), its architecture and build setup can be adapted for integrating other JavaScript libraries into Python projects.

## About the `jsonic` lenient JSON parser
(Content of this section remains unchanged)
...

## About `pythonmonkey`
(Content of this section remains unchanged)
...

## Notes for Maintainers

### Automated Workflows

The package uses GitHub Actions for automation:

1.  **CI/CD Workflow (`ci.yml`)**:
    *   Triggered on pushes, pull requests, and manual dispatch.
    *   Prepares the environment, installs dependencies (Python and JS).
    *   Runs `pre-commit` checks to ensure code quality and formatting.
    *   Runs `pytest` for automated tests.
    *   Builds the package.
    *   On version tags (e.g., `v1.2.3`), publishes the package to PyPI and creates a GitHub Release.

2.  **JS Dependencies Update (`update-js.yml`)**:
    *   Runs weekly and can be triggered manually.
    *   Updates JS dependencies in `js_src/package-lock.json`.
    *   Runs `npm audit --audit-level=critical` to check for vulnerabilities.
    *   Rebuilds the JS bundle (`src/salvajson/salvajson.js`).
    *   Creates a Pull Request with the changes for review.

### Required Secrets

Set up these secrets in your GitHub repository settings (`Settings > Secrets and variables > Actions`):

- `PYPI_TOKEN`: An API token from PyPI with permission to upload packages to the `salvajson` project.

### Versioning and Releasing

This project uses [`python-semantic-release`](https://python-semantic-release.readthedocs.io/) for versioning and release automation, driven by [Conventional Commits](https://www.conventionalcommits.org/).

- **Versioning**: The version is stored in `src/salvajson/_version.py` and dynamically determined by `hatch-vcs` from Git tags during the build process. `python-semantic-release` manages these tags.
- **Changelog**: `CHANGELOG.md` is automatically updated by `python-semantic-release` based on conventional commit messages.
- **Releasing**:
    1.  Ensure all changes are committed to the `main` branch (or your release branch).
    2.  Make sure commit messages follow the Conventional Commits format (e.g., `feat: ...`, `fix: ...`, `chore: ...`). This is enforced locally by `commitlint` if pre-commit hooks are installed.
    3.  To make a release, a maintainer with appropriate permissions would typically run:
        ```bash
        semantic-release publish
        ```
        This command will:
        *   Determine the next version based on commit messages.
        *   Update `src/salvajson/_version.py` with the new version.
        *   Update `CHANGELOG.md`.
        *   Commit these changes with a "chore(release): ..." message.
        *   Create a new Git tag for the version (e.g., `v0.2.0`).
        *   Push the commit and tag to the remote repository.
    4.  Pushing the tag automatically triggers the "PyPI Publishing" job in the `ci.yml` workflow, which builds the package and uploads it to PyPI, then creates a GitHub Release with notes from the changelog.

Alternatively, if `python-semantic-release` is configured to handle the PyPI upload and GitHub release directly (e.g. `upload_to_pypi = true` and `upload_to_release = true` in its config, and the CI job is adjusted), then `semantic-release publish` would do everything. The current setup uses CI for the final publish step after `semantic-release` tags.
The `ci.yml` workflow handles publishing to PyPI when a version tag (e.g., `vX.Y.Z`) is pushed. `python-semantic-release` is configured to create these tags and update changelogs. The typical release process would be:
1. Ensure your `main` branch has the commits you want to release.
2. Run `semantic-release publish` locally (or via a dedicated release workflow if set up). This will:
    - Determine the new version.
    - Update `CHANGELOG.md`.
    - Commit the changelog and version bump.
    - Create and push the new git tag (e.g., `v0.2.0`).
3. Pushing the tag triggers the `publish` job in `ci.yml`, which builds and uploads to PyPI and creates a GitHub Release.
